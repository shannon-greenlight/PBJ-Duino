 /** * Divides a given PWM pin frequency by a divisor. *  * The resulting frequency is equal to the base frequency divided by * the given divisor: *   - Base frequencies: *      o The base frequency for pins 3, 9, 10, and 11 is 31250 Hz. *      o The base frequency for pins 5 and 6 is 62500 Hz. *   - Divisors: *      o The divisors available on pins 5, 6, 9 and 10 are: 1, 8, 64, *        256, and 1024. *      o The divisors available on pins 3 and 11 are: 1, 8, 32, 64, *        128, 256, and 1024. *  * PWM frequencies are tied together in pairs of pins. If one in a * pair is changed, the other is also changed to match: *   - Pins 5 and 6 are paired on timer0 *   - Pins 9 and 10 are paired on timer1 *   - Pins 3 and 11 are paired on timer2 *  * Note that this function will have side effects on anything else * that uses timers: *   - Changes on pins 3, 5, 6, or 11 may cause the delay() and *     millis() functions to stop working. Other timing-related *     functions may also be affected. *   - Changes on pins 9 or 10 will cause the Servo library to function *     incorrectly. *  * Thanks to macegr of the Arduino forums for his documentation of the * PWM frequency divisors. His post can be viewed at: *   http://forum.arduino.cc/index.php?topic=16612#msg121031 */void setPwmFrequency(int pin, int divisor) {  byte mode;  if(pin == 5 || pin == 6 || pin == 9 || pin == 10) {    switch(divisor) {      case 1: mode = 0x01; break;      case 8: mode = 0x02; break;      case 64: mode = 0x03; break;      case 256: mode = 0x04; break;      case 1024: mode = 0x05; break;      default: return;    }    if(pin == 5 || pin == 6) {      TCCR0B = TCCR0B & 0b11111000 | mode;    } else {      TCCR1B = TCCR1B & 0b11111000 | mode;    }  } else if(pin == 3 || pin == 11) {    switch(divisor) {      case 1: mode = 0x01; break;      case 8: mode = 0x02; break;      case 32: mode = 0x03; break;      case 64: mode = 0x04; break;      case 128: mode = 0x05; break;      case 256: mode = 0x06; break;      case 1024: mode = 0x07; break;      default: return;    }    TCCR2B = TCCR2B & 0b11111000 | mode;  }}void analogWriteSAH_Init( void ){  // Stop the timer while we muck with it  TCCR1B = (0 << ICNC1) | (0 << ICES1) | (0 << WGM13) | (0 << WGM12) | (0 << CS12) | (0 << CS11) | (0 << CS10);    // Set the timer to mode 14...  //  // Mode  WGM13  WGM12  WGM11  WGM10  Timer/Counter Mode of Operation  TOP   Update of OCR1x at TOV1  Flag Set on  //              CTC1   PWM11  PWM10  // ----  -----  -----  -----  -----  -------------------------------  ----  -----------------------  -----------  // 14    1      1      1      0      Fast PWM                         ICR1  BOTTOM                   TOP    // Set output on Channel A to...  //  // COM1A1  COM1A0  Description  // ------  ------  -----------------------------------------------------------  // 1       0       Clear OC1A/OC1B on Compare Match (Set output to low level).    TCCR1A =       (1 << COM1A1) | (0 << COM1A0) |   // COM1A1, COM1A0 = 1, 0      (0 << COM1B1) | (0 << COM1B0) |       (1 << WGM11) | (0 << WGM10);      // WGM11, WGM10 = 1, 0    // Set TOP to...  //  // fclk_I/O = 16000000  // N        = 1  // TOP      = 799  //  // fOCnxPWM = fclk_I/O / (N * (1 + TOP))  // fOCnxPWM = 16000000 / (1 * (1 + 799))  // fOCnxPWM = 16000000 / 800  // fOCnxPWM = 20000  ICR1 = 799;    // Ensure the first slope is complete  TCNT1 = 0;    // Ensure Channel B is irrelevant    OCR1B = 0;    // Ensure Channel A starts at zero / off    OCR1A = 0;    // We don't need no stinkin interrupts    TIMSK1 = (0 << ICIE1) | (0 << OCIE1B) | (0 << OCIE1A) | (0 << TOIE1);  // Ensure the Channel A pin is configured for output  DDRB |= (1 << DDB1);  // Start the timer...  //  // CS12  CS11  CS10  Description  // ----  ----  ----  ------------------------  // 0     0     1     clkI/O/1 (No prescaling)  TCCR1B =       (0 << ICNC1) | (0 << ICES1) |       (1 << WGM13) | (1 << WGM12) |              // WGM13, WGM12 = 1, 1      (0 << CS12) | (0 << CS11) | (1 << CS10);}void analogWriteSAH( uint16_t value ){  if ( (value >= 0) && (value < 800) )  {    OCR1A = value;  }}